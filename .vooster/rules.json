{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구 사항 문서 (PRD)\n\n## 1. 총괄 개요\n본 프로젝트는 웹 기반 “TODO-LIST” 서비스로, 사용자가 해야 할 작업을 명확히 정리·우선순위화·추적할 수 있도록 지원한다. 직관적 UI, 간단한 작업 입력, 마감일·우선순위·알림 기능을 통해 생산성과 삶의 질을 향상시키는 것이 핵심 가치이다.\n\n## 2. 문제 정의\n- 사용자는 머릿속 혹은 종이 플래너에 의존해 작업을 관리하며, 정보 누락·우선순위 혼란·마감일 경과 등의 불편을 겪고 있다.  \n- 기존 복잡한 프로젝트 관리 툴은 개인 사용자에게 과도한 기능으로 부담이 된다.  \n- 모바일/데스크톱 간 일정 동기화가 부족하여 어디서든 작업 현황 파악이 어렵다.\n\n## 3. 목표 및 목적\n- 1차 목표: 개인 작업 관리 과정 단순화 및 시각화\n- 2차 목표: 동기부여 요소(완료 체크, 통계) 제공\n- 성공 지표  \n  - 주간 활성 사용자(MAU) 5,000명 3개월 내 달성  \n  - 신규 가입 후 3주차 주간 재방문율 40% 이상  \n  - 작업 추가→완료 전환 비율 60% 이상  \n  - 평균 페이지 로드 시간 1초 이내\n\n## 4. 대상 사용자\n### 주요 사용자\n- 중·고등학생, 대학생, 초·중급 직장인  \n- 특징: 단순·직관적 화면 선호, 모바일·PC 다중 사용, 반복 과제·시험·업무 관리 필요\n### 이해관계자\n- 생산성 커뮤니티·블로거  \n- 교육 기관(학습 계획 관리)  \n- 광고·프로모션 파트너\n\n## 5. 사용자 스토리\n- 학생으로서, 과제를 잊지 않도록 마감일을 지정하고 알림을 받아 과제 누락을 방지하고 싶다.  \n- 직장인으로서, 우선순위별로 오늘 해야 할 업무만 필터링하여 집중하고 싶다.  \n- 반복 루틴을 가진 사용자로서, 매일 아침 운동을 자동 생성하여 지속적인 습관 형성에 활용하고 싶다.  \n- 멀티 디바이스 사용자로서, PC에서 추가한 작업을 모바일에서 이어서 보고 편집하고 싶다.\n\n## 6. 기능 요구 사항\n\n#### 인증 및 회원가입 기능\n1. 회원가입 (이메일, 아이디, 비밀번호 입력)\n   - 이메일 유효성 및 중복 체크, 비밀번호 최소 8자·영문/숫자 조합\n   - Acceptance: 입력 오류 시 실시간 안내, 성공 시 즉시 로그인\n2. 로그인 (이메일 혹은 구글 중 선택)\n   - 이메일/비밀번호 입력 또는 구글 계정 OAuth 선택\n   - Acceptance: 인증 성공 시 2초 이내 메인 화면 이동\n3. 구글 로그인 버튼: 사용자가 Google 계정으로 빠르게 로그인/회원가입할 수 있도록 지원 (이메일 회원가입 옵션과 병행)\n   - Acceptance: 구글 OAuth 인증 성공 시 2초 이내 서비스 메인 화면으로 이동\n### 핵심 기능\n1. 작업 추가/수정/삭제  \n   - 입력창에 텍스트 입력 후 Enter 시 즉시 리스트에 추가  \n   - 리스트의 기존 작업 항목 클릭 시, 인라인 편집 모드로 전환하여 내용 수정 가능  \n   - 수정 후 Enter 혹은 포커스 아웃 시 변경사항 저장, 100ms 내 리스트 반영  \n   - 삭제 아이콘 클릭 시 해당 항목 영구 제거  \n   - Acceptance: 작업 추가, 수정, 삭제 모두 100ms 내 리스트 반영, 수정 시 입력값 검증 및 에러 안내\n\n2. 완료 체크/상태 표시  \n   - 체크박스 클릭 시 완료 상태, 회색 처리·취소선 UI  \n   - “완료 보기 토글”로 완료 항목 숨김/표시\n\n3. 마감일·일정 설정  \n   - Date picker 제공, 서버 UTC 기준 저장  \n   - 남은 기간 D-Day 배지 표시\n\n4. 우선순위 설정  \n   - 3단계(높음/중간/낮음) 색상 태그  \n   - 우선순위별 정렬 옵션\n\n5. 일/주 단위 뷰 필터  \n   - ‘오늘’, ‘이번 주’, ‘전체’ 탭 전환  \n   - 각 탭 클릭 시 200ms 내 필터링 수행\n\n6. 알림/푸시  \n   - 브라우저 Notification API, 모바일 PWA 푸시  \n   - 마감 1시간·하루 전 2단계 알림\n\n7. 간단한 UI/UX  \n   - Material Design Lite 기반, 3계층 이하 네비게이션\n\n### 부가 기능 (Nice-to-Have)\n- 반복 작업 설정: cron 형태 주기 입력 UI  \n- 카테고리/태그: #study, #work, #health 등 선택식  \n- 캘린더 통합: 월간 캘린더 뷰, 드래그 이동  \n- 다크 모드: 시스템 테마 감지 자동 전환  \n- 데이터 백업/동기화: Supabase Auth + Realtime Sync  \n- 협업: 리스트 공유 URL, 권한(읽기/쓰기)  \n- 통계/리포트: 주간 완료율 그래프, 미루기 횟수  \n- 습관 추적: 별도 Habit 탭, 연속 성공 일수 표시\n\n## 7. 비기능 요구 사항\n- 성능: 첫 화면 LCP 1s 이하, 상호작용 100ms 이하  \n- 보안: Supabase JWT Auth, HTTPS, XSS/CSRF 차단  \n- 사용성: WCAG 2.1 AA, 키보드 네비게이션 지원  \n- 확장성: 최대 동시 접속 10만, Supabase 오토스케일  \n- 호환성: Chrome, Edge, Safari, Firefox 최신 2버전, PWA 지원\n\n## 8. 기술 고려사항\n- 아키텍처: Frontend(HTML/CSS/Vanilla JS) + Backend(Supabase Postgres, Realtime)  \n- 데이터 모델: tasks(id, user_id, title, due_date, priority, status, repeat_rule, tags, created_at)  \n- API: Supabase REST/RPC, Row-level Security  \n- 배포: Vercel, CDN edge network  \n- 3rd Party: Notification API, Service Worker, Chart.js(통계)\n\n## 9. 성공 지표\n- 사용자 지표:  \n  - DAU/MAU ≥ 25%  \n  - 평균 세션 4분 이상  \n- 비즈니스 지표:  \n  - 프리미엄 전환율 3%  \n  - 구독 해지율 < 2%/월  \n- 기술 지표:  \n  - 오류율 < 0.1%  \n  - 99.9% 가용성\n\n## 10. 일정 및 마일스톤\n- Phase 1 (MVP, 0~2개월)  \n  - 작업 CRUD, 완료 체크, 마감일, 우선순위, 필터, 기본 알림  \n  - 모바일 반응형, Supabase 인증, 로컬 스토리지 캐시  \n- Phase 2 (2~4개월)  \n  - 반복 작업, 태그, 캘린더 뷰, 다크 모드, PWA 오프라인  \n- Phase 3 (4~6개월)  \n  - 협업 공유, 통계/리포트, 습관 추적, 프리미엄 구독 결제  \n  - 글로벌 언어 지원, 마켓플레이스 런칭\n\n## 11. 위험 및 대응\n- 기술적 위험: 브라우저 푸시 지원 불일치 → FCM 대체, 폴백 이메일 알림  \n- 비즈니스 위험: 경쟁 앱 대비 차별성 부족 → 학습 습관·통계 특화로 포지셔닝  \n- 사용자 확보 위험: 초기 인지도 낮음 → 대학·직장인 커뮤니티 베타 테스트, SNS 챌린지 이벤트\n\n## 12. 향후 고려 사항\n- AI 추천: 우선순위 자동 제안, 스마트 리마인드  \n- GPT 기반 음성 입력·자연어 작업 생성  \n- 서드파티 캘린더(구글·아웃룩) 양방향 동기화  \n- 오픈 API 공개로 외부 개발자 생태계 구축",
      "writedAt": "2025-07-24T06:22:27.491Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구 사항 문서 (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  간단하고 직관적인 웹 기반 TODO-LIST 서비스로, Vanilla JS와 Supabase를 활용하여 작업 CRUD, 필터, 알림 등 핵심 기능을 1초 이내 로드·100ms 이내 상호작용으로 구현합니다. Vercel을 통한 정적 리소스 호스팅과 Supabase의 인증·데이터베이스·실시간 기능을 결합해 최소한의 운영 비용으로 안정적인 서비스 제공을 목표로 합니다.\n\n- **핵심 기술 스택**  \n  • Frontend: HTML/CSS/Vanilla JS + Material Design Lite  \n  • Backend: Supabase(Postgres, Auth, Realtime)  \n  • Hosting: Vercel + CDN Edge Network  \n  • Notification: Service Worker + Notification API\n\n- **주요 기술 목표**  \n  • 최초 화면 LCP 1s 이하 달성  \n  • UI 상호작용 응답 100ms 이하  \n  • 동시 접속자 10만 이상 대응  \n  • 99.9% 이상 가용성 보장\n\n- **주요 가정**  \n  • 사용자 데이터는 Supabase Postgres에 저장 및 RLS로 보호  \n• 인증은 Supabase Auth(이메일+아이디+비밀번호 회원가입/로그인, Google OAuth)로 제공하며, 기본은 이메일 기반 인증\n  • PWA 오프라인 기능 구현은 Phase2 이후 진행  \n\n## 2. Tech Stack\n\n| Category           | Technology / Library               | Reasoning (선택 이유)                                               |\n| ------------------ | ---------------------------------- | ------------------------------------------------------------------- |\n| Frontend Framework | Vanilla JS + HTML/CSS              | 경량·빠른 초기 로드, 복잡도 최소화                                  |\n| UI 컴포넌트        | Material Design Lite               | 직관적 디자인, 추가 커스터마이징 없이 빠른 UI 구축                  |\n| 상태 관리          | 브라우저 내장 state                | 간단한 작업 리스트에 별도 라이브러리 불필요                           |\n| 데이터베이스       | Supabase Postgres                  | 오토스케일, 실시간 업데이트, RLS 지원                               |\n| 인증               | Supabase Auth (Email, Username, Password, Google OAuth) | 이메일/아이디 기반 회원가입 및 로그인, 추가적으로 Google OAuth 제공, JWT 기반 보안 |\n| 실시간 통신        | Supabase Realtime                  | WebSocket 기반 실시간 작업 동기화                                    |\n| 알림(푸시)         | Service Worker + Notification API  | 브라우저 및 PWA 푸시 지원                                           |\n| 날짜 처리          | Day.js (CDN)                       | 손쉬운 D-Day 계산                                                    |\n| 통계 차트          | Chart.js (CDN)                     | 가벼운 차트 라이브러리, 기본 통계 시각화                             |\n| 호스팅/배포        | Vercel                             | Git 연동 CI/CD, 글로벌 CDN                                           |\n| 코드 품질          | ESLint (Optional)                  | 코드 일관성 유지 (Vanilla JS 프로젝트에서 선택적 적용)               |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- Client (브라우저/PWA)  \n  • UI 렌더링, 사용자 입력 처리, Service Worker 등록  \n  • Supabase JS SDK를 통한 인증·데이터 조회/수정  \n- Backend (Supabase)  \n  • Postgres DB · Realtime · Auth · Storage  \n  • Row-level Security, Cloud Function(RPC)  \n- CDN & Hosting (Vercel)  \n  • 정적 자산 호스팅, 자동 빌드·배포, 글로벌 엣지 캐싱  \n- Notification Service  \n  • Service Worker가 Notification API 호출  \n  • 마감 1시간·하루 전 브라우저 푸시\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n  Client[브라우저(PWA)] -->|Auth/API| Auth[Supabase Auth]\n  Client -->|CRUD/Realtime| DB[Supabase Postgres]\n  Client -->|Realtime| Realtime[Supabase Realtime]\n  Client -->|푸시 등록| SW[Service Worker]\n  SW -->|Notification API| Client\n```\n- 브라우저가 Supabase Auth를 통해 로그인/토큰 획득  \n- 동일한 브라우저에서 Supabase JS SDK로 CRUD/API 호출  \n- Realtime 구독으로 다른 기기 변경 사항 즉시 반영  \n- Service Worker가 푸시 등록·수신 후 Notification API 호출\n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**  \n- Domain Separation: `auth`, `tasks`, `notifications` 등 도메인별 폴더  \n- Layer-Based Architecture: Presentation(UI), Business Logic(도메인 서비스), Data Access(Supabase Client)  \n- Feature-Based Modules: 각 도메인 내 기능별 파일 구성  \n- Shared Components: `utils.js`, `api.js`, `constants.js` 등 공통 모듈\n\n**Universal File & Folder Structure**\n```\n/\n├── index.html\n├── styles.css\n├── sw.js\n├── scripts\n│   ├── auth.js\n│   ├── tasks.js\n│   ├── notifications.js\n│   ├── api.js\n│   └── utils.js\n├── assets\n│   └── icons/\n└── libs\n    ├── dayjs.min.js\n    └── chart.min.js\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Supabase JS SDK 통한 REST/RPC 호출  \n- **Database Interaction**: Supabase Postgres에 RLS 적용, SQL RPC for 복잡 쿼리  \n- **User Authentication Flow**: Supabase Auth를 활용하여 이메일, 아이디, 비밀번호 기반 회원가입/로그인 지원, 추가적으로 Google OAuth 통합  \n- **Real-time Communication**: Supabase Realtime 채널 구독  \n- **Data Synchronization**: 브라우저 로컬 캐시 + Realtime 이벤트로 동기화\n\n## 4. Performance & Optimization Strategy\n- 정적 자산 CDN 캐싱 헤더 설정(immutable, max-age)  \n- 필요 리소스만 로드하는 최소화된 `<script>` 구조  \n- Day.js/Chart.js CDN 서브리소스 병렬 로드  \n- Service Worker로 오프라인 캐시 및 네트워크 우선 정책  \n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Supabase 프로젝트 생성, Vercel 배포 설정  \n- **Essential Features**: 작업 CRUD, 완료 체크, 마감일·우선순위, ‘오늘·이번 주·전체’ 필터, 기본 알림  \n- **Basic Security**: HTTPS, Supabase JWT Auth, RLS 정책  \n- **Development Setup**: Git 레포, 브랜치 모델, Vercel CI/CD  \n- **Timeline**: 0~2개월\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 반복 작업(cron UI), 카테고리/태그, 달력 뷰, 다크 모드, PWA 오프라인  \n- **Performance Optimization**: 코드 스플리팅, 이미지 최적화  \n- **Enhanced Security**: CSP, 추가 RLS 규칙, CSRF 방어  \n- **Monitoring Implementation**: Supabase Logs, Vercel Analytics  \n- **Timeline**: 2~4개월\n\n### Phase 3: Scaling & Optimization\n- **Scalability Implementation**: Supabase 오토스케일, edge functions 활용  \n- **Advanced Integrations**: 프리미엄 구독 결제, 협업 권한 관리  \n- **Enterprise Features**: 공유 URL, 읽기/쓰기 권한 분리  \n- **Compliance & Auditing**: GDPR·정보보안 표준 대응  \n- **Timeline**: 4~6개월\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **Technology Risks**: Service Worker 브라우저별 호환성 차이 → FCM 폴백, 이메일 알림  \n- **Performance Risks**: Realtime 구독 과다 → 적절한 구독 분리, 배치 처리  \n- **Security Risks**: XSS/CSRF 공격 → CSP, Supabase RLS 강화  \n- **Integration Risks**: Supabase 장애 시 데이터 접근 차단 → 로컬 캐시 폴백, 장애 모니터링  \n- **Mitigation Strategies**: 폴백 경로 설계, 정기 부하 테스트, 보안 감사\n\n### Project Delivery Risks\n- **Timeline Risks**: 외부 API 지연 → 기본 기능 우선 개발, Mock 데이터 활용  \n- **Resource Risks**: Vanilla JS 경험 부족 → 기술 워크숍, 샘플 코드 제공  \n- **Quality Risks**: 테스트 부족 → 유닛·통합 테스트 스크립트 추가  \n- **Deployment Risks**: Vercel 빌드 실패 → 로컬 CI, 복구용 이전 배포 버전 유지  \n- **Contingency Plans**: 핵심 기능 집중, Phase 조정 및 외부 컨설팅 활용",
      "writedAt": "2025-07-24T06:22:27.491Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-24T06:22:27.491Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-24T06:22:27.491Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-24T06:22:27.491Z"
    }
  ]
}